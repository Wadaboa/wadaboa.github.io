<h3 id="introduction">Introduction</h3>

<p>One key idea in <strong>OOP (Object-Oriented Programming)</strong> is the so-called <strong>information hiding</strong>, which is a form of abstraction whereby the public interface of an object gets <em>decoupled</em> from its internal workings. This concept of separation is usually the core idea of <em>abstract classes</em> and <em>interfaces</em>, in which a set of customers (a <em>concrete class</em>) would like that each customer (an <em>instance</em> of the concrete class) could use the service (an <em>interface’s function</em>) provided by a specific supplier (the <em>interface</em>). In this blog post we are going to develop a deeper understanding of what interfaces are, in general, and how they differ from a programming language to another.</p>

<h3 id="java-interfaces">Java interfaces</h3>

<p>In <strong>Java</strong>, an <strong>interface</strong> is very similar to an abstract class, with the following main differences:</p>
<ul>
  <li>Interfaces are declared using the <code class="highlighter-rouge">interface</code> keyword, rather than the <code class="highlighter-rouge">class</code> keyword</li>
  <li>A class can implement an interface using the <code class="highlighter-rouge">implements</code> keyword, rather than the <code class="highlighter-rouge">extends</code> keyword</li>
  <li>Functions are declared as abstract methods, i.e. they don’t provide an implementation</li>
  <li>Functions are automatically declared with the <code class="highlighter-rouge">public</code> visibility</li>
  <li>Variables are automatically declared as <code class="highlighter-rouge">public</code>, <code class="highlighter-rouge">static</code> and <code class="highlighter-rouge">final</code>, since an interface cannot be directly instantiated</li>
</ul>

<p>The cool thing about interfaces is that they provide a way to perform a sort of <em>multiple inheritance</em>, since a class can implement more than one interface, while also eventually extending a single class. For example:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">foo</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">B</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">bar</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">C</span> <span class="kd">implements</span> <span class="no">A</span><span class="o">,</span> <span class="no">B</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">baz</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<p>An interface can also extend another interface, by means of the same <strong>inheritance</strong> rules applied to standard Java classes. For example:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">foo</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">B</span> <span class="kd">extends</span> <span class="no">A</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">bar</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Since <strong>Java 8</strong>, interfaces got richer, with additional important features which brings them closer to other implementations of the same concepts in other languages, like Scala. These useful new features free the programmer from the constraints imposed by having to stick with just abstract methods in interfaces. For example, with Java 8 you can implement a <strong>static function</strong> directly in the interface, leading to very useful applications like standard <em>factory methods</em>:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nf">A</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="no">A</span> <span class="nf">factory</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">B</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">B</span> <span class="kd">implements</span> <span class="nf">A</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</code></pre></div></div>

<p>Another useful addition is in the so called <code class="highlighter-rouge">default</code> methods, which are a good way to provide default implementations of some interface functions. In this way, classes that implement that specific interface are not obliged to provide the actual code to perform that operation, to be declared as concrete classes. Obviously, this feature is mostly related to the scalability of an interface, rather than to its core operations, since the best practice for a class implementing that interface will always be to provide its specific implementation of the default method.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="k">default</span> <span class="kt">boolean</span> <span class="nf">foo</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="scala-traits">Scala traits</h3>

<p><strong>Scala</strong> traits are very similar to Java interfaces, since they provide a way to inject specific behaviors into a class, using a set of methods defined in the implemented trait. These behaviors should then be parametrized, according to the actual mission of the class.</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">foo</span><span class="o">()</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Scala traits could be seen as rich interfaces, since they provide a way to implement both abstract and <strong>non-abstract</strong> function definitions, out of the box. For example, we could have the following definition, without the need of using the <code class="highlighter-rouge">default</code> keyword, as in Java 8:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">foo</span><span class="o">()</span> <span class="k">=</span> <span class="nf">println</span><span class="o">(</span><span class="s">"foo"</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>A Scala <em>class/object</em> can inherit from multiple traits at the same time. For the <em>single inheritance problem</em>, we could have:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">foo</span><span class="o">()</span> <span class="k">=</span> <span class="nf">println</span><span class="o">(</span><span class="s">"foo"</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">B</span><span class="o">()</span> <span class="k">extends</span> <span class="n">A</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">bar</span><span class="o">()</span> <span class="k">=</span> <span class="nf">println</span><span class="o">(</span><span class="s">"bar"</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>For the <em>multiple inheritance problem</em>, we could instead have:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="k">override</span> <span class="k">def</span> <span class="nf">foo</span><span class="o">()</span> <span class="k">=</span> <span class="nf">println</span><span class="o">(</span><span class="s">"foo"</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">B</span> <span class="o">{</span>
    <span class="k">override</span> <span class="k">def</span> <span class="nf">foo</span><span class="o">()</span> <span class="k">=</span> <span class="nf">println</span><span class="o">(</span><span class="s">"bar"</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">C</span><span class="o">()</span> <span class="k">extends</span> <span class="n">A</span> <span class="k">with</span> <span class="n">B</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">bar</span><span class="o">()</span> <span class="k">=</span> <span class="nf">println</span><span class="o">(</span><span class="s">"bar"</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Alternatively to <code class="highlighter-rouge">class C() extends A with B</code>, we could have also written <code class="highlighter-rouge">class C() with A with B</code>.<br />
Beware that the <strong>order</strong> in which traits are listed actually matters, since the last trait will be considered first in case of traits that override methods (in our example, calling <code class="highlighter-rouge">foo()</code> on an instance of type <code class="highlighter-rouge">C</code> will print out “<em>bar</em>” instead of “<em>foo</em>”).</p>

<p>A very useful thing which distinguishes Java 8 interfaces with default methods w.r.t. Scala traits is that the latter provide the so called <strong>dynamic binding</strong> of <code class="highlighter-rouge">super</code>: the <code class="highlighter-rouge">super</code> keyword can be used inside a trait to refer to the superclass of the class implementing the trait. Obviously, the <code class="highlighter-rouge">super</code> keyword cannot be <em>statically interpreted</em> because the trait can be mixed-in different classes, with different superclasses; so, it has to be <em>dinamically bound</em> to the superclass of the mixed-in class. For example:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">foo</span><span class="o">()</span> <span class="k">=</span> <span class="nf">println</span><span class="o">(</span><span class="nv">super</span><span class="o">.</span><span class="py">toString</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">B</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">override</span> <span class="k">def</span> <span class="nf">toString</span> <span class="k">=</span> <span class="s">"Superclass"</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">C</span><span class="o">()</span> <span class="k">extends</span> <span class="n">B</span> <span class="k">with</span> <span class="n">A</span> <span class="o">{</span>
    <span class="k">override</span> <span class="k">def</span> <span class="nf">toString</span> <span class="k">=</span> <span class="s">"Derived class"</span>
<span class="o">}</span>
</code></pre></div></div>
<p>In this example, calling <code class="highlighter-rouge">foo()</code> on an instance of <code class="highlighter-rouge">class C</code> will actually print out “<em>Superclass</em>”.</p>

<p>These tools give the programmer an easy way to <strong>extend</strong> the language with new primitives and mechanisms that resemble <strong>native</strong>, in order to “<em>scale</em>” the software to suit its needs.</p>
